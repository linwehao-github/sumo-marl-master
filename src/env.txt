from collections import defaultdict, deque
import os
import pickle
import random
import shutil
random.seed(42)
import torch
import traci
from sumolib import checkBinary
import numpy as np
from sumolib.net import readNet
import torch.nn as nn
from xml.etree import ElementTree as ET

class TrafficEnv:
    def __init__(self, mode='binary'):
        # If the mode is 'gui', it renders the scenario.
        if mode == 'gui':
            self.sumoBinary = checkBinary('sumo-gui')
        else:
            self.sumoBinary = checkBinary('sumo')
        self.sumoCmd = [self.sumoBinary, "-c", './scenario/openmap.sumocfg', '--no-step-log', '-W']
        net = readNet('./scenario/openmap.net.xml')
        self.time = None
        self.decision_time = 10
        self.tl_ids = [tl.getID() for tl in net.getTrafficLights()]  # 获取ID字符串
        self.n_intersections = len(self.tl_ids)
        self.lstm_extension = nn.LSTM(input_size=1, hidden_size=4, batch_first=True)
        self.extension_fc = nn.Linear(8, 1)
        self.extension_memory = deque(maxlen=3)  # 记忆最近5个时间步的数据
        # 初始化时先连接SUMO获取相位信息
        traci.start(self.sumoCmd)
        self.max_lanes = max(len(traci.trafficlight.getControlledLanes(tl_id)) 
                            for tl_id in traci.trafficlight.getIDList())
        self.phase_limits = {}  # 存储每个路口的最大相位索引
        for tl_id in self.tl_ids:
            # 获取该路口的所有相位定义
            logic = traci.trafficlight.getAllProgramLogics(tl_id)[0]
            self.phase_limits[tl_id] = len(logic.phases) - 1  # 最大相位索引
        self.n_phase = max(self.phase_limits.values()) + 1 if self.phase_limits else 0
        self.state_dim = 4 * self.max_lanes + self.n_phase
        traci.close()
        # 添加车辆类型配置
        self.vehicle_types = {
            'emergency': {'priority': 3, 'threshold': 1},
            'commuter': {'priority': 2, 'threshold': 5},
        }
        # 相位延长参数（秒）
        self.phase_extension = {
            'emergency': 30,'commuter': 15
        }
    def _detect_congestion(self):
        """检测路网中的拥堵情况"""
        congested_edges = set()
        for edge in traci.edge.getIDList():
            # 计算车道占用率
            lane_count = traci.edge.getLaneNumber(edge)
            total_vehicles = 0
            total_capacity = 0
            
            for lane_idx in range(lane_count):
                lane_id = f"{edge}_{lane_idx}"
                total_vehicles += traci.lane.getLastStepVehicleNumber(lane_id)
                total_capacity += traci.lane.getLastStepVehicleNumber(lane_id) / traci.lane.getLength(lane_id)
            
            if total_capacity > 0 and (total_vehicles / total_capacity) > self.congestion_threshold:
                congested_edges.add(edge)
        
        return congested_edges
    def detect_special_vehicles(self, intersection_id):
        """检测当前路口需要优先处理的车辆"""
        lanes = traci.trafficlight.getControlledLanes(intersection_id)
        vehicle_counts = {'emergency': 0, 'commuter': 0}
        
        for lane in lanes:
            vehicles = traci.lane.getLastStepVehicleIDs(lane)
            for veh in vehicles:
                v_type = traci.vehicle.getTypeID(veh)
                if v_type in self.vehicle_types:
                    if v_type == 'emergency':
                        vehicle_counts['emergency'] += 1
                    elif v_type == 'commuter':
                        vehicle_counts['commuter'] += 1
        return vehicle_counts
    def adaptive_phase_control(self, intersection_id):
        # 获取当前相位信息
        current_phase = traci.trafficlight.getPhase(intersection_id)
        logic = traci.trafficlight.getAllProgramLogics(intersection_id)[0]
        phase_def = logic.phases[current_phase].state
        controlled_lanes = traci.trafficlight.getControlledLanes(intersection_id)
        
        # 识别绿灯方向
        green_lanes = []
        for lane_idx, signal in enumerate(phase_def):
            if signal == 'G' and lane_idx < len(controlled_lanes):
                green_lanes.append(controlled_lanes[lane_idx])
                traci.lane.setParameter(controlled_lanes[lane_idx], "color", "0,255,0")

        # 统计绿灯方向车流
        vehicle_count = sum(
            len(traci.lane.getLastStepVehicleIDs(lane))
            for lane in green_lanes
        )
        
        # 更新记忆
        self.extension_memory.append([vehicle_count])
        
        if len(self.extension_memory) == 3:  # 只有记忆满了才使用LSTM
            # 转换为tensor并添加batch维度
            history = torch.FloatTensor([self.extension_memory])
            
            # LSTM处理
            lstm_out, (hn, cn) = self.lstm_extension(history)
            
            # 正确获取趋势值
            trend = hn[0, -1, 0].item()  # 获取最后一个时间步的第一个隐藏单元
            
            # 决策规则
            if green_lanes and (vehicle_count >= 5 or trend > 0.5):
                remaining = traci.trafficlight.getNextSwitch(intersection_id) - traci.simulation.getTime()
                extension = min(10, 20)
                new_duration = remaining + extension
                traci.trafficlight.setPhaseDuration(intersection_id, new_duration)
                return True
        
        return False

    def reset(self):
        traci.start(self.sumoCmd)
        traci.simulationStep()
        self.time = 0
        return self.get_state()

    def get_state(self):
        # 定义每个路口的状态维度
        # 每个车道: 车辆数(1) + 停车数(1) + 紧急车辆数(1) + 通勤车辆数(1) = 4个特征
        # 加上相位信息(n_phase)
        state_dim = 4 * self.max_lanes + self.n_phase
        
        states = []
        for tl_id in traci.trafficlight.getIDList():
            obs = []
            lanes = traci.trafficlight.getControlledLanes(tl_id)
            
            # 收集车道数据
            for lane in lanes:
                # 基础数据
                obs.append(traci.lane.getLastStepVehicleNumber(lane))
                obs.append(traci.lane.getLastStepHaltingNumber(lane))
                
                # 车辆类型统计
                vehicles = traci.lane.getLastStepVehicleIDs(lane)
                emergency = sum(1 for v in vehicles if traci.vehicle.getTypeID(v) == 'emergency')
                commuter = sum(1 for v in vehicles if traci.vehicle.getTypeID(v) == 'commuter')
                obs.extend([emergency, commuter])
            
            # 补零对齐
            while len(obs) < 4 * self.max_lanes:
                obs.append(0.0)
            
            # 添加相位信息
            phase = [0] * self.n_phase
            current_phase = traci.trafficlight.getPhase(tl_id)
            if current_phase < len(phase):
                phase[current_phase] = 1
            obs.extend(phase)
            
            states.append(obs)
        
        return np.array(states, dtype=np.float32)

    def apply_action(self, actions):
        for i, tl_id in enumerate(traci.trafficlight.getIDList()):
            max_phase = self.phase_limits.get(tl_id, 0)
            safe_action = min(actions[i], max_phase)  # 确保不超限
            current_phase = traci.trafficlight.getPhase(tl_id)
            if safe_action != current_phase:
                traci.trafficlight.setPhase(tl_id, safe_action)

    def step(self, actions):
        self.apply_action(actions)
        for _ in range(self.decision_time):
            for tl_id in traci.trafficlight.getIDList():
                self.adaptive_phase_control(tl_id)
            traci.simulationStep()
            self.time += 1
        state = self.get_state()
        reward = self.get_reward()
        done = self.get_done()
        return state, reward, done

    def get_reward(self):
        reward = [0.0 for _ in range(self.n_intersections)]
        for i, intersection_ID in enumerate(traci.trafficlight.getIDList()):
            for lane in traci.trafficlight.getControlledLanes(intersection_ID):
                reward[i] += traci.lane.getLastStepHaltingNumber(lane)
            # 添加优先车辆奖励项
            vehicle_counts = self.detect_special_vehicles(intersection_ID)
            if vehicle_counts['emergency'] > 0:
                reward[i] -= 10 * vehicle_counts['emergency']  # 紧急车辆权重更高
            if vehicle_counts['commuter'] > 5:  # 超过5辆就有惩罚
                reward[i] -= 2 * (vehicle_counts['commuter'] - 5)
        return -np.array(reward)

    def get_done(self):
        return traci.simulation.getMinExpectedNumber() == 0

    def close(self):
        traci.close()
        if os.path.exists("modified_departures.pkl"):
            os.remove("modified_departures.pkl")  # 清理临时文件


if __name__ == "__main__":
    env = TrafficEnv()
    state = env.reset()
